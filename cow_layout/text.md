В мае 2023 года [я писал (telegram)](https://t.me/dereference_pointer_there/5373) об оптимизации расчёта раскладки типов в памяти, которая в итоге дошла до стейбла в версии 1.71.0. В частности, я упомянул, что благодаря этой оптимизации размер `Cow<'a, str>` и `String` стал одинаковым. Ещё во время чтения этого PR я подумал, что это изменение должно было несколько ухудшить получение `&str` из `&Cow<str>`, ведь если первый `usize` в раскладке используется одновременно как указатель и как дискриминант, то в итоговом коде должно быть ветвление, которое загружает данные толстого указателя (собственно указатель и длину) в зависимости от значения первого `usize`. И действительно, если скомпилировать вот такую функцию:

```rust
fn get_str<'s>(cow: &'s Cow<str>) -> &'s str {
    match cow {
        Cow::Owned(s) => s,
        Cow::Borrowed(s) => s,
    }
}
```

(да, я знаю, что можно было бы написать просто `cow.as_ref()`, но это менее наглядно и внутри там всё равно то же самое)

, то на версии 1.71.0 после чутка оптимизаций получаем вот такой код:

```
get_str:
        mov     rax, qword ptr [rdi]
        mov     rdx, qword ptr [rdi + 16]
        test    rax, rax
        jne     .LBB0_2
        mov     rax, qword ptr [rdi + 8]
.LBB0_2:
        ret
```

Как видите, в регистр rdx значение загружается безусловно, а вот значение, записанное в rax, сравнивается с нулём и при равенстве нулю перезаписывается. Я думал, что до принятия этого изменения никакого ветвления не было, поскольку у `&str` и `String` адрес данных и длина лежат в одних местах, а потому и ветвиться не было необходимости... Но я не проверил это на опыте — и зря, потому что кодген на деле даже улучшился по сравнению с предыдущей версией.

Именно, если скомпилировать ту же функцию на версии 1.70.0, то получится вот такой код:

```
get_str:
        cmp     qword ptr [rdi], 0
        mov     rdx, qword ptr [rdi + 16]
        mov     rax, qword ptr [rdi + 8]
        cmovne  rax, rdx
        cmovne  rdx, qword ptr [rdi + 24]
        ret
```

Иными словами, тут ветвление в неявном виде через [conditional move](https://www.felixcloutier.com/x86/cmovcc). Что ещё хуже, это условное перемещение данных записывает из одного регистра в другой, что сильно портит граф зависимостей по данным и связывает руки процессору по части параллелизма на уровне инструкций. Очевидно, мои представления по поводу раскладки `&str` и `String` в памяти были неверны. Но что же действительно произошло?

Я сделаю небольшое отступление, но в итоге вернусь к этому вопросу.

Именно, вы когда-нибудь задумывались, как стабильный rustc компилирует std, которая вообще-то использует кучу нестабильных фич? На самом деле компилятор стабильной версии — это компилятор одной из ночных версий, в котором обрублены ночные фичи. Но код для них всё ещё имеется. В частности, каждая следующая стабильная версия компилятора собирается при помощи предыдущей стабильной версии. Именно поэтому в rustc есть секретная кнопка фича: переменная окружения `RUSTC_BOOTSTRAP`. Именно, если эта переменная окружения установлена, то rustc считает, что используется для бустрапинга, а потому разрешает использовать нестабильные фичи.

И среди них есть та, что нам нужна! Именно, `-Zprint-type-sizes`. Скомбинировав установление нужной переменной окружения и этого флага, мы получаем информацию о раскладке в памяти используемых в программе типов.

(можно было бы, конечно, использовать nightly-версии, соответствующие stable напрямую, но это менее удобно — и, что немаловажно, на godbolt.org можно использовать только последнюю версию nightly)

Что же нам известно о раскладке типов? `String` является обёрткой над `Vec<u8>`, `Vec<T>` является обёрткой на `RawVec<T>` с добавленным полем `len`, а `RawVec<T>` является абстракцией над выделенным при помощи аллокатора памятью и содержит поля для указателя и ёмкости (и аллокатора, но глобальный аллокатор является типом нулевого размера, так что нам это не особо важно).

(RawVec также используется для реализации `VecDeque`)

Вооружившись этим знанием, посмотрим на отдельные части вывода `-Zprint-type-sizes`. Сначала для 1.70.0:

<details>
<summary>1.70.0</summary>

```
print-type-size type: `std::borrow::Cow<'_, str>`: 32 bytes, alignment: 8 bytes
print-type-size     discriminant: 8 bytes
print-type-size     variant `Owned`: 24 bytes
print-type-size         field `.0`: 24 bytes
print-type-size     variant `Borrowed`: 16 bytes
print-type-size         field `.0`: 16 bytes
print-type-size type: `std::string::String`: 24 bytes, alignment: 8 bytes
print-type-size     field `.vec`: 24 bytes
print-type-size type: `std::vec::Vec<u8>`: 24 bytes, alignment: 8 bytes
print-type-size     field `.buf`: 16 bytes
print-type-size     field `.len`: 8 bytes
print-type-size type: `alloc::raw_vec::RawVec<u8>`: 16 bytes, alignment: 8 bytes
print-type-size     field `.alloc`: 0 bytes
print-type-size     field `.cap`: 8 bytes
print-type-size     field `.ptr`: 8 bytes
```

</details>

Теперь для 1.71.0:

<details>
<summary>1.71.0</summary>

```
print-type-size type: `std::borrow::Cow<'_, str>`: 24 bytes, alignment: 8 bytes
print-type-size     variant `Borrowed`: 24 bytes
print-type-size         padding: 8 bytes
print-type-size         field `.0`: 16 bytes, alignment: 8 bytes
print-type-size     variant `Owned`: 24 bytes
print-type-size         field `.0`: 24 bytes
print-type-size type: `std::string::String`: 24 bytes, alignment: 8 bytes
print-type-size     field `.vec`: 24 bytes
print-type-size type: `std::vec::Vec<u8>`: 24 bytes, alignment: 8 bytes
print-type-size     field `.buf`: 16 bytes
print-type-size     field `.len`: 8 bytes
print-type-size type: `alloc::raw_vec::RawVec<u8>`: 16 bytes, alignment: 8 bytes
print-type-size     field `.alloc`: 0 bytes
print-type-size     field `.ptr`: 8 bytes
print-type-size     field `.cap`: 8 bytes
```

</details>

Для наглядности представим оба варианта графически. Вот раскладка для версии 1.70.0, до оптимизации:

```
       ┌───────┬───────┬───────┬───────┐
  &str │       │  ptr  │  len  │       │
       │ discr ├───────┼───────┼───────┤
String │       │  cap  │  ptr  │  len  │
       └───────┴───────┴───────┴───────┘
```

А вот так в 1.71.0, после оптимизации:

```
       ┌───────┬───────┬───────┐
  &str │       │  ptr  │  len  │
       ├───────┼───────┼───────┤
String │  ptr  │  cap  │  len  │
       └───────┴───────┴───────┘
```

Это объясняет поведение, которое мы ранее видели в коде. До 1.71.0 указатель и длина располагались внахлёст, что требовало двух перезаписей, а после 1.71.0 места под длины совпадали, так что в случае `Cow::Borrowed` требовалась только перезапись указателя.

Так можно ли сделать ещё лучше? Да! Именно, на последней стабильной версии (и вообще начиная с версии 1.76.0) код для `get_str` выглядит вот так:

```
get_str:
        mov     rax, qword ptr [rdi + 8]
        mov     rdx, qword ptr [rdi + 16]
        ret
```

Данные просто перемещаются в регистры по фиксированным смещениям от указателя, без ветвлений! Как это вышло? Если снова посмотреть на раскладку типов в памяти, то можно увидеть, что между версиями 1.75.0 и 1.76.0 поменялась раскладка типа `RawVec`:

```
print-type-size type: `alloc::raw_vec::RawVec<u8>`: 16 bytes, alignment: 8 bytes
print-type-size     field `.cap`: 8 bytes
print-type-size     field `.ptr`: 8 bytes
print-type-size     field `.alloc`: 0 bytes
```

Иными словами, теперь поле `cap` находится на первом месте, и раскладка `Cow<str>` в памяти выглядит вот так:

```
       ┌───────┬───────┬───────┐
  &str │       │  ptr  │  len  │
       ├───────┼───────┼───────┤
String │  cap  │  ptr  │  len  │
       └───────┴───────┴───────┘
```

Но в чём же дело, разве ёмкость не является `usize`? Как оказывается — нет, и это поменялось в [PR #106790](https://github.com/rust-lang/rust/pull/106790). В этом PR (который, видимо, и ответственен за изменение в раскладке) тип поля `cap` поменяли с `usize` на специальный тип `Cap`, у которого диапазон валидных значений [оканчивается на `isize::MAX`](https://github.com/rust-lang/rust/pull/106790/files#diff-e2a4f36a3e53f497d9b6257c46f39ddcc9bad9285ef3e740959b67436ea22086R32). Как следствие, у этого поля теперь есть ниша, которая может быть использована для оптимизации раскладки.

Напоследок хочется задать вопрос: неужели это — оптимальный вариант? Увы, нет: оптимизация раскладки в памяти — это всегда компромисс. До добавления ниши к `RawVec` код для ветвления по дискриминанту:

```rust
fn is_borrowed(cow: &Cow<str>) -> bool {
    matches!(cow, Cow::Borrowed(_))
}
```

выглядел вот так:

```
is_borrowed:
        cmp     qword ptr [rdi], 0
        sete    al
        ret
```

, а после этого изменения — вот так:

```
is_borrowed:
        movabs  rax, -9223372036854775808 ; или 0x8000_0000_0000_0000
                                          ; только старший бит установлен
        cmp     qword ptr [rdi], rax
        sete    al
        ret
```

Иными словами, новая версия вынуждена грузить литерал в регистр и только потом сравнивать. Не смотря на то, что инструкция `cmp` на архитектуре x86 позволяет сравнивать 64-битные значения, ограничения по размеру инструкции не позволяет использовать литеральное значение больше 32 бит, а для данного магического числа все 64 бита обязательны. Более того, среди [вариантов кодировки `cmp`](https://www.felixcloutier.com/x86/cmp) есть те, которые позволяют толковать литеральное значение как 32-битное, расширенное до 64-битного, но расширение при это происходит знаковое ([sign extension](https://en.wikipedia.org/wiki/Sign_extension)), что, очевидно, в данной ситуации не подходит.
